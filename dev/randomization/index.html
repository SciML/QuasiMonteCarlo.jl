<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Randomization methods ¬∑ QuasiMonteCarlo.jl</title><meta name="title" content="Randomization methods ¬∑ QuasiMonteCarlo.jl"/><meta property="og:title" content="Randomization methods ¬∑ QuasiMonteCarlo.jl"/><meta property="twitter:title" content="Randomization methods ¬∑ QuasiMonteCarlo.jl"/><meta name="description" content="Documentation for QuasiMonteCarlo.jl."/><meta property="og:description" content="Documentation for QuasiMonteCarlo.jl."/><meta property="twitter:description" content="Documentation for QuasiMonteCarlo.jl."/><meta property="og:url" content="https://docs.sciml.ai/QuasiMonteCarlo/stable/randomization/"/><meta property="twitter:url" content="https://docs.sciml.ai/QuasiMonteCarlo/stable/randomization/"/><link rel="canonical" href="https://docs.sciml.ai/QuasiMonteCarlo/stable/randomization/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="QuasiMonteCarlo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuasiMonteCarlo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../samplers/">Sampler APIs</a></li><li class="is-active"><a class="tocitem" href>Randomization methods</a><ul class="internal"><li><a class="tocitem" href="#API-for-randomization"><span>API for randomization</span></a></li><li><a class="tocitem" href="#Scrambling-methods"><span>Scrambling methods</span></a></li><li><a class="tocitem" href="#Other-methods"><span>Other methods</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../design_matrix/">Design Matrices</a></li><li><a class="tocitem" href="../types/">Choosing the right type (Float32, Float64, etc.)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Randomization methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Randomization methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/QuasiMonteCarlo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/master/docs/src/randomization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Randomization"><a class="docs-heading-anchor" href="#Randomization">Randomization methods</a><a id="Randomization-1"></a><a class="docs-heading-anchor-permalink" href="#Randomization" title="Permalink"></a></h1><p>Most of the methods presented in <a href="../samplers/#Samplers">Sampler</a> are deterministic, i.e. <code>X = sample(n, d, ::DeterministicSamplingAlgorithm)</code> will always produce the same sequence <span>$X = (X_1, \dots, X_n)$</span>.</p><p>The main issue with deterministic Quasi Monte Carlo sampling is that it does not allow easy error estimation as opposed to plain Monte Carlo, where the variance can be estimated.</p><p>A Randomized Quasi Monte Carlo method must respect the two following criteria:</p><ol><li>Have <span>$X_i\sim \mathbb{U}([0,1]^d)$</span> for each <span>$i\in \{1,\cdots, n\}$</span>.</li><li>Preserve the QMC properties, i.e. the randomized <span>$X$</span> still has low discrepancy.</li></ol><p>This randomized version is unbiased and can be used to obtain a confidence interval or to do sensitivity analysis.</p><p>A good reference is the <a href="https://artowen.su.domains/mc/qmcstuff.pdf">book by A. Owen</a>, especially the Chapters 15, 16 and 17.</p><h2 id="API-for-randomization"><a class="docs-heading-anchor" href="#API-for-randomization">API for randomization</a><a id="API-for-randomization-1"></a><a class="docs-heading-anchor-permalink" href="#API-for-randomization" title="Permalink"></a></h2><pre><code class="language-julia hljs">abstract type RandomizationMethod end</code></pre><p>There are two ways to obtain a randomized sequence:</p><ul><li>Either directly use <code>QuasiMonteCarlo.sample(n, d, DeterministicSamplingAlgorithm(R = SomeRandomizationMethod()))</code> or <code>sample(n, lb, up, DeterministicSamplingAlgorithm(R = RandomizationMethod()))</code>.</li><li>Or, given <span>$n$</span> points <span>$d$</span>-dimensional points, all in <span>$[0,1]^d$</span> one can do <code>randomize(X, SomeRandomizationMethod())</code> where <span>$X$</span> is a <span>$d\times n$</span>-matrix.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuasiMonteCarlo.randomize" href="#QuasiMonteCarlo.randomize"><code>QuasiMonteCarlo.randomize</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randomize(x, R::Shift)</code></pre><p>Cranley Patterson Rotation i.e. <code>y = (x .+ U) mod 1</code> where <code>U ‚àº ùïå([0,1]·µà)</code> and <code>x</code> is a <code>d√ón</code> matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/6dad807fa4a96428a37942cd33bd1a5fd38c1f8c/src/RandomizedQuasiMonteCarlo/shifting.jl#L14-L18">source</a></section><section><div><pre><code class="language-julia hljs">randomize(x, R::ScrambleMethod)</code></pre><p>Return a scrambled version of <code>x</code>. The scramble methods implemented are</p><ul><li><code>DigitalShift</code>.</li><li><code>OwenScramble</code>: Nested Uniform Scramble which was introduced in Owen (1995).</li><li><code>MatousekScramble</code>: Linear Matrix Scramble which was introduced in Matousek (1998).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/6dad807fa4a96428a37942cd33bd1a5fd38c1f8c/src/RandomizedQuasiMonteCarlo/scrambling_base_b.jl#L18-L27">source</a></section></article><p>The default method of <code>DeterministicSamplingAlgorithm</code> is <code>NoRand</code></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuasiMonteCarlo.NoRand" href="#QuasiMonteCarlo.NoRand"><code>QuasiMonteCarlo.NoRand</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoRand &lt;: RandomizationMethod</code></pre><p>No randomization is performed on the sampled sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/6dad807fa4a96428a37942cd33bd1a5fd38c1f8c/src/QuasiMonteCarlo.jl#L85-L91">source</a></section></article><p>To obtain multiple independent randomizations of a sequence, i.e. Design Matrices, look at the <a href="../design_matrix/#DesignMatrices">Design Matrices section</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In most other QMC packages, randomization is performed &quot;online&quot; as the points are samples. Here, randomization is performed after the deterministic sequence is generated. Both methods are useful in different contexts. The former is generally faster to produce one randomized sequence, while the latter is faster to produce independent realizations of the sequence.</p><p><strong>PRs are welcomed</strong> to add &quot;online&quot; version of the sequence! See <a href="https://github.com/SciML/QuasiMonteCarlo.jl/pull/57#issuecomment-1326662016">this comment for inspiration</a>.</p><p>Another way to view the two approaches is: given a computational budget of <span>$N$</span> points, one can</p><ol><li>Put all of it into a sequence of size, <span>$N$</span>, thus having the best estimator <span>$\hat{\mu}_N$</span>. The price to pay is that this estimation is not associated with a variance estimation.</li><li>Divide your computational budget into <span>$N = n\times M$</span> to get <span>$M$</span> independent estimator <span>$\hat{\mu}_n$</span>. From there, one can compute the empirical variance of the estimator.</li></ol></div></div><h2 id="Scrambling-methods"><a class="docs-heading-anchor" href="#Scrambling-methods">Scrambling methods</a><a id="Scrambling-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Scrambling-methods" title="Permalink"></a></h2><pre><code class="language-julia hljs">abstract type ScrambleMethod &lt;: RandomizationMethod end</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuasiMonteCarlo.ScrambleMethod" href="#QuasiMonteCarlo.ScrambleMethod"><code>QuasiMonteCarlo.ScrambleMethod</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScrambleMethod &lt;: RandomizationMethod</code></pre><p>A scramble method needs at least the scrambling base <code>b</code>, the number of &quot;bits&quot; to use <code>pad</code> (<code>pad=32</code> is the default) and a seed <code>rng</code> (<code>rng = Random.GLOBAL_RNG</code> is the default). The scramble methods implementer are</p><ul><li><code>DigitalShift</code>.</li><li><code>OwenScramble</code>: Nested Uniform Scramble which was introduced in Owen (1995).</li><li><code>MatousekScramble</code>: Linear Matrix Scramble which was introduced in Matousek (1998).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/6dad807fa4a96428a37942cd33bd1a5fd38c1f8c/src/RandomizedQuasiMonteCarlo/scrambling_base_b.jl#L4-L15">source</a></section></article><p><code>ScramblingMethods(b, pad, rng)</code> are well suited for <span>$(t,m,d)$</span>-nets in base <span>$b$</span>. <code>b</code> is the base used to scramble and <code>pad</code> the number of bits in <code>b</code>-ary decomposition, i.e. <span>$y \simeq \sum_{k=1}^{\texttt{pad}} y_k/\texttt{b}^k$</span>.</p><p>The <code>pad</code> is generally chosen as <span>$\gtrsim \log_b(n)$</span>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In principle, the base <code>b</code> used for scrambling methods <code>ScramblingMethods(b, pad, rng)</code> can be an arbitrary integer. However, to preserve good Quasi Monte Carlo properties, it must match the base of the sequence to scramble. For example, (deterministic) Sobol sequences are base <span>$b=2$</span>, <span>$(t,m,d)$</span> sequences while (deterministic) Faure sequences are <span>$(t,m,d)$</span> sequences in prime base i.e. <span>$b$</span> is an arbitrary prime number.</p></div></div><p>The implemented <code>ScramblingMethods</code> are</p><ul><li><code>DigitalShift</code> the simplest and fastest method. For a point <span>$x\in [0,1]^d$</span> it does <span>$y_k = (x_k + U_k) \mod b$</span> where <span>$U_k \sim \mathbb{U}(\{0, \cdots, b-1\})$</span></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuasiMonteCarlo.DigitalShift" href="#QuasiMonteCarlo.DigitalShift"><code>QuasiMonteCarlo.DigitalShift</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DigitalShift &lt;: ScrambleMethod</code></pre><p>Digital shift. <code>randomize(x, R::DigitalShift)</code> returns a scrambled version of <code>x</code>.</p><p>The scramble method is Digital Shift. It scrambles each coordinate in base <code>b</code> as <code>y‚Çñ = (x‚Çñ + U‚Çñ) mod b</code> where <code>U‚Çñ ‚àº ùïå({0:b-1})</code>. <code>U</code> is the same for every point <code>points</code> but i.i.d. along every dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/6dad807fa4a96428a37942cd33bd1a5fd38c1f8c/src/RandomizedQuasiMonteCarlo/scrambling_base_b.jl#L231-L242">source</a></section></article><ul><li><code>MatousekScramble</code> a.k.a. Linear Matrix Scramble is what people use in practice. Indeed, the observed performances are similar to <code>OwenScramble</code> for a lesser numerical cost.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuasiMonteCarlo.MatousekScramble" href="#QuasiMonteCarlo.MatousekScramble"><code>QuasiMonteCarlo.MatousekScramble</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatousekScramble &lt;: ScrambleMethod</code></pre><p>Linear Matrix Scramble aka Matousek&#39;s scramble.</p><p><code>randomize(x, R::MatousekScramble)</code> returns a scrambled version of <code>x</code>. The scramble method is Linear Matrix Scramble which was introduced in Matousek (1998). <code>pad</code> is the number of bits used for each point. One needs <code>pad ‚â• log(base, n)</code>.</p><p>References: Matou≈°ek, J. (1998). On thel2-discrepancy for anchored boxes. Journal of Complexity, 14(4), 527-556.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/6dad807fa4a96428a37942cd33bd1a5fd38c1f8c/src/RandomizedQuasiMonteCarlo/scrambling_base_b.jl#L158-L170">source</a></section></article><ul><li><code>OwenScramble</code> a.k.a. Nested Uniform Scramble is the most understood theoretically, but is more costly to operate.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuasiMonteCarlo.OwenScramble" href="#QuasiMonteCarlo.OwenScramble"><code>QuasiMonteCarlo.OwenScramble</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OwenScramble &lt;: ScrambleMethod</code></pre><p>Nested Uniform Scramble aka Owen&#39;s scramble.</p><p><code>randomize(x, R::OwenScramble)</code> returns a scrambled version of <code>x</code>. The scramble method is Nested Uniform Scramble which was introduced in Owen (1995). <code>pad</code> is the number of bits used for each point. One needs <code>pad ‚â• log(base, n)</code>.</p><p>References: Owen, A. B. (1995). Randomly permuted (t, m, s)-nets and (t, s)-sequences. In Monte Carlo and Quasi-Monte Carlo Methods in Scientific Computing: Proceedings of a conference at the University of Nevada, Las Vegas, Nevada, USA, June 23‚Äì25, 1994 (pp. 299-317). Springer New York.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/6dad807fa4a96428a37942cd33bd1a5fd38c1f8c/src/RandomizedQuasiMonteCarlo/scrambling_base_b.jl#L34-L46">source</a></section></article><h2 id="Other-methods"><a class="docs-heading-anchor" href="#Other-methods">Other methods</a><a id="Other-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Other-methods" title="Permalink"></a></h2><p><code>Shift(rng)</code> a.k.a. Cranley-Patterson Rotation. It is by far the fastest method; it is used in <code>LatticeRuleScramble</code> for example.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuasiMonteCarlo.Shift" href="#QuasiMonteCarlo.Shift"><code>QuasiMonteCarlo.Shift</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Shifting(rng::AbstractRNG = Random.GLOBAL_RNG) &lt;: RandomizationMethod</code></pre><p>Cranley-Patterson rotation aka Shifting</p><p>References: Cranley, R., &amp; Patterson, T. N. (1976). Randomization of number theoretic methods for multiple integration. SIAM Journal on Numerical Analysis, 13(6), 904-914.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/6dad807fa4a96428a37942cd33bd1a5fd38c1f8c/src/RandomizedQuasiMonteCarlo/shifting.jl#L1-L9">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Randomization of a Faure sequence with various methods.</p><h3 id="Generation"><a class="docs-heading-anchor" href="#Generation">Generation</a><a id="Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Generation" title="Permalink"></a></h3><pre><code class="language-julia hljs">using QuasiMonteCarlo, Random
Random.seed!(1234)
m = 4
d = 3
b = QuasiMonteCarlo.nextprime(d)
N = b^m # Number of points
pad = m # Can also choose something as `2m` to get &quot;better&quot; randomization

# Unrandomized low discrepancy sequence
x_faure = QuasiMonteCarlo.sample(N, d, FaureSample())

# Randomized version
x_uniform = rand(d, N) # plain i.i.d. uniform
x_shift = randomize(x_faure, Shift())
x_nus = randomize(x_faure, OwenScramble(base = b, pad = pad)) # equivalent to sample(N, d, FaureSample(R = OwenScramble(base = b, pad = pad)))
x_lms = randomize(x_faure, MatousekScramble(base = b, pad = pad))
x_digital_shift = randomize(x_faure, DigitalShift(base = b, pad = pad))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3√ó81 Matrix{Float64}:
 0.567901  0.901235  0.234568  0.345679  ‚Ä¶  0.518519   0.851852  0.185185
 0.037037  0.37037   0.703704  0.481481     0.0246914  0.358025  0.691358
 0.493827  0.82716   0.160494  0.271605     0.888889   0.222222  0.555556</code></pre><h3 id="Visualization-of-different-methods"><a class="docs-heading-anchor" href="#Visualization-of-different-methods">Visualization of different methods</a><a id="Visualization-of-different-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-different-methods" title="Permalink"></a></h3><p>Plot the resulting sequences along dimensions <code>1</code> and <code>3</code>.</p><pre><code class="language-julia hljs">using Plots
# Setting I like for plotting
default(fontfamily = &quot;Computer Modern&quot;,
    linewidth = 1,
    label = nothing,
    grid = true,
    framestyle = :default)

d1 = 1
d2 = 3 # you can try every combination of dimension (d1, d2)
sequences = [x_uniform, x_faure, x_shift, x_digital_shift, x_lms, x_nus]
names = [
    &quot;Uniform&quot;,
    &quot;Faure (deterministic)&quot;,
    &quot;Shift&quot;,
    &quot;Digital Shift&quot;,
    &quot;Matousek Scramble&quot;,
    &quot;Owen Scramble&quot;
]
p = [plot(thickness_scaling = 1.5, aspect_ratio = :equal) for i in sequences]
for (i, x) in enumerate(sequences)
    scatter!(p[i], x[d1, :], x[d2, :], ms = 1.5, c = 1, grid = false)
    title!(names[i])
    xlims!(p[i], (0, 1))
    ylims!(p[i], (0, 1))
    yticks!(p[i], [0, 1])
    xticks!(p[i], [0, 1])
    hline!(p[i], range(0, 1, step = 1 / 4), c = :gray, alpha = 0.2)
    vline!(p[i], range(0, 1, step = 1 / 4), c = :gray, alpha = 0.2)
    hline!(p[i], range(0, 1, step = 1 / 2), c = :gray, alpha = 0.8)
    vline!(p[i], range(0, 1, step = 1 / 2), c = :gray, alpha = 0.8)
end
plot(p..., size = (800, 600))</code></pre><img src="5ddfc1b4.svg" alt="Example block output"/><h3 id="(t,m,d)-net-visualization"><a class="docs-heading-anchor" href="#(t,m,d)-net-visualization"><span>$(t,m,d)$</span>-net visualization</a><a id="(t,m,d)-net-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#(t,m,d)-net-visualization" title="Permalink"></a></h3><p>Faure nets and their scrambled versions are digital <span>$(t,m,d)$</span>-net, which means they have strong equipartition properties. On the following plot, we can (visually) verify that with Nested Uniform Scrambling, it also works with Linear Matrix Scrambling and Digital Shift. You must see one point per rectangle of volume <span>$1/b^m$</span>. Points on the &quot;left&quot; border of rectangles are included, while those on the &quot;right&quot; are excluded. See <a href="https://artowen.su.domains/mc/qmcstuff.pdf">Chapter 15.7</a> and Figure 15.10 for more details.</p><pre><code class="language-julia hljs">d1 = 1
d2 = 3 # you can try every combination of dimension (d1, d2)
x = x_nus # Owen Scramble, you can try x_lms and x_digital_shift
p = [plot(thickness_scaling = 1.5, aspect_ratio = :equal) for i in 0:m]
for i in 0:m
    j = m - i
    x·µ¢ = range(0, 1, step = 1 / b^(i))
    x‚±º = range(0, 1, step = 1 / b^(j))
    scatter!(p[i + 1], x[d1, :], x[d2, :], ms = 1.5, c = 1, grid = false)
    xlims!(p[i + 1], (0, 1.01))
    ylims!(p[i + 1], (0, 1.01))
    yticks!(p[i + 1], [0, 1])
    xticks!(p[i + 1], [0, 1])
    hline!(p[i + 1], x·µ¢, c = :gray, alpha = 0.2)
    vline!(p[i + 1], x‚±º, c = :gray, alpha = 0.2)
end
plot(p..., size = (800, 600))</code></pre><img src="c2df69da.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To check if a point set is a <span>$(t,m,d)$</span>-net, you can use the function <code>istmsnet</code> defined in the <a href="https://github.com/SciML/QuasiMonteCarlo.jl/blob/2dce9905e564a85e1280115cc8af071674fc7d80/test/runtests.jl#L34">tests file</a> of this package. It uses the excellent <a href="https://github.com/JuliaIntervals/IntervalArithmetic.jl">IntervalArithmetic.jl</a> package.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../samplers/">¬´ Sampler APIs</a><a class="docs-footer-nextpage" href="../design_matrix/">Design Matrices ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 24 November 2024 22:31">Sunday 24 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
