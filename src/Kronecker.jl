"""
    KroneckerSample{V} <: SamplingAlgorithm
    KroneckerSample(origin::AbstractVector, generator::AbstractVector)
    KroneckerSample(d::Integer, args...)

A Kronecker sequence is a point set generated by a pair of vectors and the equation:
`x[i] = (origin + i * generator) .% 1`

Where `i` runs from `1` through the sample size `n`. This sequence will be equidistributed
(uniform in the infinite limit) so long as the components of `generator` are linearly
independent over the field of rational numbers.

If `origin` is not specified, it is assumed to be equal to 0. If only a dimension is
specified, a parametrization based on the generalized golden ratio is used, but this is
known to give poor samples for dimensions higher than 3--see

Kronecker sequences are not recommended for use in more than 3 dimensions, as theory on them
is sparse. `LatticeRuleSample` will return rank-1 lattice rules, which behave similarly to
Kronecker sequences but have better-understood properties.

References:
Leobacher, G., & Pillichshammer, F. (2014). *Introduction to quasi-Monte Carlo integration and applications.* Switzerland: Springer International Publishing.
https://link.springer.com/content/pdf/10.1007/978-3-319-03425-6.pdf
"""
struct KroneckerSample{V} <: SamplingAlgorithm
    generator::V
    origin::V
end

function KroneckerSample(generator::AbstractVector)
    return KroneckerSample(generator, (similar(generator) .= 0))
end

KroneckerSample(generator, origin) = KroneckerSample(promote(generator, origin)...)

KroneckerSample() = KroneckerSample(missing, missing)

@fastmath function radiant(d::Integer, tol::T = eps(float(d))) where {T}
    y_old = one(T)
    # Approximate solution of x^(d+1) = x + 1 (nested radical)
    y = (one(T) + y_old)^-inv(d)
    while abs(y - y_old) > tol  # continue until precise enough
        y_old = y
        y = (one(T) + y)^-inv(d)
    end
    return y
end

function sample(n::Integer, d::Integer, k::KroneckerSample)
    @assert d == length(k.generator)
    return @. mod(k.generator * (0:(n - 1))' + k.origin, 1)
end

"""
    GoldenSample(origin)

Generate a quasirandom Kronecker sequence using powers of the generalized golden ratio.

The harmonious, or generalized golden, ratios are defined as the solutions to the equation:
``x^d = x + 1``

Where `d` is the dimension of the sequence. The Golden sequence is then equivalent to
`Kronecker([x^-i for i in 1:d])`.

WARNING: the generalized golden sequence in more than 2 dimensions is purely experimental.
It likely has poor discrepancy in high dimensions, and should not be used without verifying
answers against a better-known quasirandom sequence. Try a rank-1 lattice rule.

References:
Roberts, M. (2018). The Unreasonable Effectiveness of Quasirandom Sequences.
*Extreme Learning.*
http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/
"""
struct GoldenSample{T} <: SamplingAlgorithm
    origin::T
end
GoldenSample() = GoldenSample(zero(Float64))

function sample(n::Integer, d::Integer, g::GoldenSample{T}) where {T}
    ratio = harmonious(d, eps(eltype(T)))
    generator = [ratio^-i for i in 1:d]
    return @. mod(generator * (0:(n - 1))' + g.origin, 1)
end

# generate (inverse) harmonious numbers
@fastmath function harmonious(d::Integer, tol::T = 2eps(float(d))) where {T}
    y_old = one(T)
    # Approximate solution of x^(d+1) = x + 1 (nested radical)
    y = (one(T) + y_old)^inv(d + 1)
    while abs(y - y_old) > tol  # continue until precise enough
        y_old = y
        y = (one(T) + y)^inv(d + 1)
    end
    return y
end
